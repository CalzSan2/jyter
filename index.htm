






<html><head><base href="https://tower-defense.example.com/" />
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jyter 0.4.8</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  body {
    margin: 0;
    padding: 0;
    font-family: 'Press Start 2P', cursive;
    background: linear-gradient(to bottom, #0c0c2c, #2c0c3c);
    color: #00ff00;
    overflow: hidden;
  }
  .fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background-color: #000;
    color: #00ff00;
    z-index: 9999;
    border: 4px solid #00ff00;
  }
  #loadingScreen {
    background-color: #111;
  }
  .spinner {
    width: 50px;
    height: 50px;
    border: 5px solid #00ff00;
    border-top: 5px solid #ffff00;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  #lobby {
    background-color: #0c0c2c;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  .lobby-container {
    max-width: 800px;
    width: 100%;
    padding: 20px;
    text-align: center;
  }
  
  .game-title {
    font-size: 3rem;
    color: #00ff00;
    text-shadow: 0 0 10px #00ffff;
    margin-bottom: 2rem;
  }
  
  .version {
    font-size: 1rem;
    color: #ffff00;
  }
  
  .lobby-menu {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    margin-bottom: 2rem;
  }
  
  .menu-card {
    background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
    border: 2px solid #00ff00;
    border-radius: 10px;
    padding: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  
  .menu-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(0, 255, 255, 0.3);
    border-color: #ffff00;
  }
  
  .menu-icon {
    font-size: 2.5rem;
    margin-bottom: 10px;
  }
  
  .menu-card h3 {
    color: #ffff00;
    margin: 10px 0;
  }
  
  .menu-card p {
    color: #00ffff;
    font-size: 0.9rem;
  }
  
  .player-info {
    margin-top: 2rem;
    padding: 15px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 10px;
    border: 1px solid #00ff00;
  }
  
  .player-stats {
    display: flex;
    justify-content: center;
    gap: 20px;
    color: #ffffff;
    font-size: 1.2rem;
    margin-bottom: 10px;
  }
  
  .deck-status {
    font-size: 1rem;
    color: #ffff00;
    text-align: center;
  }
  #gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  #gameCanvas {
    border: 4px solid #00ff00;
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
  }
  #controls {
    margin-top: 20px;
    display: flex;
    align-items: center;
    gap: 20px;
  }

  #towerCounter {
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #00ff00;
    border-radius: 10px;
    padding: 10px 15px;
    font-size: 18px;
    color: #00ff00;
    text-shadow: 0 0 5px #00ff00;
    margin-right: 10px;
  }

  #manaDisplay {
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #00ffff;
    border-radius: 10px;
    padding: 10px 15px;
    font-size: 18px;
    color: #00ffff;
    text-shadow: 0 0 5px #00ffff;
    display: flex;
    align-items: center;
    gap: 8px;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
  }

  #manaDisplay::before {
    content: "‚ö°";
    font-size: 20px;
  }

  #manaBar {
    height: 20px;
    width: 150px;
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid #00ffff;
    border-radius: 10px;
    overflow: hidden;
    margin-left: 10px;
  }

  #manaFill {
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, #0066ff, #00ffff);
    transition: width 0.3s ease;
  }
  button {
    font-size: 16px;
    padding: 10px 20px;
    margin: 0 10px;
    cursor: pointer;
    background-color: #00ff00;
    color: #000;
    border: 2px solid #ffff00;
    text-shadow: 2px 2px #00ffff;
    transition: all 0.3s ease;
  }
  
  #removeTowerButton {
    background-color: #ff0000;
  }
  
  #removeTowerButton.active {
    background-color: #ffff00;
    box-shadow: 0 0 15px #ff0000;
  }
  button:hover {
    background-color: #ffff00;
    box-shadow: 0 0 10px #00ffff;
  }
  #towerCards {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    margin-top: 20px;
  }
  .tower-card {
    width: 120px;
    height: 180px;
    background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
    border: 2px solid;
    border-radius: 10px;
    margin: 10px;
    cursor: grab;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-around;
    transition: all 0.3s ease;
    box-shadow: 0 4px 6px rgba(0, 255, 255, 0.1);
    padding: 10px;
    position: relative;
    overflow: hidden;
  }
  .tower-card.comum { border-color: white; }
  .tower-card.raro { border-color: #3498db; }
  .tower-card.epico { border-color: #9b59b6; }
  .tower-card.mitico { border-color: #e74c3c; }
  .tower-card.lendario { border-color: #f1c40f; }
  .tower-card.incomum { border-color: #2ecc71; }
  .tower-card-name {
    font-size: 14px;
    font-weight: bold;
    color: #ffff00;
    text-align: center;
  }
  .tower-card-rarity {
    font-size: 12px;
    font-weight: bold;
    text-transform: uppercase;
    margin-bottom: 5px;
  }
  .tower-card-rarity.comum { color: white; }
  .tower-card-rarity.raro { color: #3498db; }
  .tower-card-rarity.epico { color: #9b59b6; }
  .tower-card-rarity.mitico { color: #e74c3c; }
  .tower-card-rarity.lendario { color: #f1c40f; }
  .tower-card-rarity.incomum { color: #2ecc71; }
  .tower-card.selected {
    box-shadow: 0 0 15px 5px rgba(255, 255, 0, 0.7);
    animation: glow 1.5s ease-in-out infinite alternate;
  }
  @keyframes glow {
    from {
      box-shadow: 0 0 10px 3px rgba(255, 255, 0, 0.7);
    }
    to {
      box-shadow: 0 0 20px 8px rgba(255, 255, 0, 0.9);
    }
  }
  .tower-card-cost {
    font-size: 14px;
    color: #ff00ff;
  }
  .tower-card-description {
    font-size: 12px;
    color: #00ffff;
    text-align: center;
    height: 60px;
    overflow: hidden;
  }
  
  .tower-card-mana-cost {
    font-size: 12px;
    color: #ffff00;
    text-align: center;
    margin-top: 5px;
  }
  #backgroundCanvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
  }
  .attribution {
    position: fixed;
    bottom: 10px;
    right: 10px;
    color: #00ff00;
    font-size: 24px;
    text-shadow: 2px 2px #ff00ff;
    font-weight: bold;
  }
  .attribution .highlight {
    font-size: 32px;
    color: #ffff00;
    text-shadow: 2px 2px #00ffff;
  }
  #pauseMenu {
    display: none;
    flex-direction: column;
    z-index: 9998;
  }
  #gameOverScreen {
    background-color: rgba(0, 0, 0, 0.8);
    z-index: 9999;
  }
  #gameOverScreen h2 {
    font-size: 48px;
    color: #ff0000;
    text-shadow: 2px 2px #000000;
  }
  #gameOverScreen p {
    font-size: 24px;
    color: #ffffff;
    margin-bottom: 20px;
  }
  #restartGameButton {
    font-size: 24px;
    padding: 15px 30px;
    cursor: pointer;
    background-color: #00ff00;
    color: #000000;
    border: 2px solid #ffff00;
    text-shadow: 2px 2px #00ffff;
  }
  #deckSelection {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }
  #towerList {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 80%;
    max-height: 70vh;
    overflow-y: auto;
    background-color: rgba(0, 0, 0, 0.5);
    border: 2px solid #00ff00;
    border-radius: 10px;
    padding: 20px;
    margin-bottom: 20px;
  }
</style>
</head>
<body>
  <div id="loadingScreen" class="fullscreen">
    <h1>Carregando Jyter 0.4.8...</h1>
    <div class="spinner"></div>
  </div>

  <div id="lobby" class="fullscreen">
    <div class="lobby-container">
      <h1 class="game-title">Jyter <span class="version">0.4.8</span></h1>
      
      <div class="lobby-menu">
        <div class="menu-card" id="battleButton">
          <div class="menu-icon">‚öîÔ∏è</div>
          <h3>Batalha</h3>
          <p>Inicie uma nova partida</p>
        </div>
        
        <div class="menu-card" id="deckButton">
          <div class="menu-icon">üÉè</div>
          <h3>Deck</h3>
          <p>Monte seu baralho</p>
        </div>
        
        <div class="menu-card" id="shopButton">
          <div class="menu-icon">üõí</div>
          <h3>Loja</h3>
          <p>Compre novas cartas</p>
        </div>
        
        <div class="menu-card" id="newsButton">
          <div class="menu-icon">üì∞</div>
          <h3>Not√≠cias</h3>
          <p>Atualiza√ß√µes e novidades</p>
        </div>
      </div>
      
      <div class="player-info">
        <div class="player-stats">
          <span>üíé <span id="playerCrystals">0</span></span>
          <span>ü™ô <span id="playerGold">0</span></span>
          <span>üèÜ <span id="playerWins">0</span></span>
        </div>
        <div class="deck-status" id="deckStatus">
          Deck: N√£o pronto (<span id="deckCount">0</span>/8 cartas)
        </div>
      </div>
    </div>
  </div>

  <div id="pauseMenu" class="fullscreen">
    <h2>Jogo Pausado</h2>
    <button id="resumeButton">Retomar</button>
    <button id="restartButton">Reiniciar</button>
  </div>

  <div id="gameOverScreen" class="fullscreen" style="display: none;">
    <h2>Game Over</h2>
    <p>Voc√™ perdeu na onda <span id="finalWave"></span></p>
    <button id="restartGameButton">Recome√ßar</button>
  </div>

  <div id="gameContainer">
    <canvas id="backgroundCanvas"></canvas>
    <div id="gameInfoContainer">
      <div id="waveInfo"></div>
      <div id="resourceInfo"></div>
    </div>
    <canvas id="gameCanvas" width="1200" height="400"></canvas>
    <div id="controls">
      <div id="towerCounter">0/7</div>
      <div id="manaDisplay">
        <span id="manaText">100%</span>
        <div id="manaBar">
          <div id="manaFill"></div>
        </div>
      </div>
      <button id="removeTowerButton">Remover Torre (‚ö°3)</button>
      <button id="backToDeckButton">Voltar ao Lobby</button>
    </div>
    <div id="gameMessage" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(255,0,0,0.7); color: white; padding: 10px; border-radius: 5px; display: none; font-size: 16px;"></div>
    <div id="towerCards"></div>
  </div>

  <div id="upgradeModal">
    <h2>Melhorar Torre</h2>
    <div id="upgradeOptions"></div>
    <button id="closeUpgradeModal">Fechar</button>
  </div>

  <div class="attribution">by <span class="highlight">calzsan</span></div>

  <script>
    const loadingScreen = document.getElementById('loadingScreen');
    const lobby = document.getElementById('lobby');
    const startGameButton = document.getElementById('startGameButton');
    const gameContainer = document.getElementById('gameContainer');

    let lives = 20;
    let mana = 0;
    let maxMana = 10;
    let manaRegenRate = 0.01; // mana per frame (1x slower)
    let maxTowers = 7;
    let lastTowerIncrease = 0;

    let availableTowers = [
      { type: 'basic', name: 'Torre de Flechas',  description: 'Alcance m√©dio, tiro lento', rarity: 'comum' },
      { type: 'rapid', name: 'Torre Metralha',  description: 'Alcance m√©dio, tiro super r√°pido', rarity: 'mitico' },
      { type: 'sniper', name: 'Torre Sniper',  description: 'Alcance super grande, tiro super lento', rarity: 'mitico' },
      { type: 'ice', name: 'Torre de Gelo',  description: 'Desacelera inimigos', rarity: 'raro' },
      { type: 'cannon', name: 'Torre de Canh√£o',  description: 'Alcance longo, elimina inimigos comuns', rarity: 'mitico' },
      { type: 'area', name: 'Torre em √Årea',  description: 'Dano significativo em √°rea', rarity: 'epico' },
      { type: 'chain', name: 'Torre de Corrente',  description: 'Desacelera inimigos progressivamente', rarity: 'incomum' },
      { type: 'bomb', name: 'Torre de Bombas',  description: 'Explode inimigos 3 vezes', rarity: 'epico' },
      { type: 'bazooka', name: 'Torre Hit Kill',  description: 'vazio roxo lento mais letal', rarity: 'comum' },
      { type: 'threeMages', name: 'Os Tr√™s Magos',  description: 'Ataca com 3 proj√©teis em sequ√™ncia', rarity: 'mitico' },
      { type: 'teleport', name: 'Torre de Teletransporte',  description: 'Teleporta inimigos para o in√≠cio', rarity: 'lendario' },
      { type: 'combat', name: 'Torre de Combate',  description: 'Alcance curto, atira com duas m√£os', rarity: 'epico' },
      { type: 'mortar', name: 'Morteiro',  description: 'Alcance hiper gigante, tiro lento, dano alto', rarity: 'epico' },
      { type: 'tesla', name: 'Torre Tesla',  description: 'Dano em √°rea com raios de choque', rarity: 'epico' },
      { type: 'superArrows', name: 'Torre de Super Flechas',  description: '3 torres em uma, alcance m√©dio', rarity: 'epico' },
      { type: 'multiShot', name: 'Torre Multitiro',  description: 'Atira em v√°rios alvos simultaneamente', rarity: 'raro' },
      { type: 'seismic', name: 'Torre S√≠smica',  description: 'Causa dano em √°rea e atordoa', rarity: 'epico' },
      { type: 'repulsao', name: 'Torre de Repuls√£o',  description: 'Empurra inimigos para o come√ßo a cada 10 segundos, afeta 1 inimigo', rarity: 'lendario' },
      { type: 'wheeled', name: 'Torre de Rodas',  description: 'Torre m√≥vel que atira em movimento', rarity: 'epico' },
      { type: 'fire', name: 'Torre de Fogo',  description: 'Dano em √°rea, causando explos√µes em massa', rarity: 'epico' }
    ];

    let spells = [
      { type: 'tornado', name: 'Tornado',  description: 'Prende inimigos por 3s, tira metade da vida', rarity: 'incomum' },
      { type: 'blackhole', name: 'Buraco Negro',  description: 'Cria um buraco negro que suga e destr√≥i inimigos', rarity: 'epico' },
      { type: 'vacuum', name: 'V√°cuo',  description: 'Suga 99% da vida de inimigos pr√≥ximos (exceto chefes)', rarity: 'epico' },
      { type: 'furia', name: 'F√∫ria',  description: 'Torre selecionada fica 3x mais r√°pida por 5s', rarity: 'raro' },
      { type: 'meteor', name: 'Chuva de Meteoros',  description: 'Meteoros caem sobre at√© 5 inimigos, causando 50% de dano ao colidir', rarity: 'epico' },
      { type: 'barreira', name: 'Barreira',  description: 'Cria uma barreira que bloqueia inimigos por 9s', rarity: 'raro' },
      { type: 'cemiterio', name: 'Cemit√©rio Lend√°rio',  description: 'Invoca 5 torres de flechas m√≥veis por 9 segundos', rarity: 'lendario' },
      { type: 'terraqueimada', name: 'Terra Queimada',  description: 'Incendeia uma √°rea causando dano cont√≠nuo por 10 segundos', rarity: 'epico' },
      { type: 'tempestadeeletrica', name: 'Tempestade El√©trica',  description: 'Lan√ßa raios em at√© 5 inimigos aleat√≥rios', rarity: 'epico' },
      { type: 'clone', name: 'Clone',  description: 'Clona uma torre por 9 segundos (25% menos dano)', rarity: 'raro' }
    ];

const manaCostsByRarity = {
  comum: 2,
  incomum: 3,
  raro: 4,
  epico: 6,
  mitico: 7,
  lendario: 8
};

availableTowers.forEach(t => {
  t.manaCost = manaCostsByRarity[t.rarity];
});

spells.forEach(s => {
  s.manaCost = manaCostsByRarity[s.rarity];
});


    let selectedDeck = [];
    
    function selectDeck() {
      const deckSelectionContainer = document.createElement('div');
      deckSelectionContainer.id = 'deckSelection';
      deckSelectionContainer.innerHTML = '<h2>Selecione 8 torres para seu deck:</h2>';

      const towerList = document.createElement('div');
      towerList.id = 'towerList';

      const allCards = [...availableTowers, ...spells];
      allCards.forEach(card => {
        const cardElement = document.createElement('div');
        cardElement.className = `tower-card ${card.rarity}`;
        cardElement.innerHTML = `
          <div class="tower-card-name">${card.name}</div>
          <div class="tower-card-rarity ${card.rarity}">${card.rarity.toUpperCase()}</div>
          <div class="tower-card-cost"><span class="resource-icon mana-icon">‚ö°</span> ${card.manaCost}</div>
          <div class="tower-card-description">${card.description}</div>
        `;
        cardElement.addEventListener('click', () => {
          if (selectedDeck.includes(card)) {
            selectedDeck = selectedDeck.filter(t => t !== card);
            cardElement.classList.remove('selected');
          } else if (selectedDeck.length < 8) {
            selectedDeck.push(card);
            cardElement.classList.add('selected');
            // Efeito visual ao selecionar
            cardElement.style.transform = 'scale(1.05)';
            setTimeout(() => {
              cardElement.style.transform = 'scale(1)';
            }, 200);
          }
          updateSelectedDeckDisplay();
        });
        towerList.appendChild(cardElement);
      });

      const totalCards = availableTowers.length + spells.length;
      const cardsFoundInfo = document.createElement('div');
      cardsFoundInfo.id = 'cardsFoundInfo';
      cardsFoundInfo.textContent = `Cartas encontradas: ${totalCards}`;
      cardsFoundInfo.style.marginTop = '20px';
      cardsFoundInfo.style.fontSize = '18px';
      cardsFoundInfo.style.color = '#00ff00';

      const selectedDeckDisplay = document.createElement('div');
      selectedDeckDisplay.id = 'selectedDeckDisplay';

      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '20px';
      buttonContainer.style.marginTop = '20px';

      const saveAndReturnButton = document.createElement('button');
      saveAndReturnButton.textContent = 'Salvar e Voltar ao Lobby';
      saveAndReturnButton.addEventListener('click', () => {
        if (selectedDeck.length === 8) {
          document.body.removeChild(deckSelectionContainer);
          lobby.style.display = 'flex';
        } else {
          alert('Por favor, selecione exatamente 8 torres para seu deck.');
        }
      });

      buttonContainer.appendChild(saveAndReturnButton);

      deckSelectionContainer.appendChild(towerList);
      deckSelectionContainer.appendChild(cardsFoundInfo);
      deckSelectionContainer.appendChild(selectedDeckDisplay);
      deckSelectionContainer.appendChild(buttonContainer);

      document.body.appendChild(deckSelectionContainer);

      function updateSelectedDeckDisplay() {
        selectedDeckDisplay.innerHTML = `<h3>Torres selecionadas (${selectedDeck.length}/8):</h3>`;
        selectedDeck.forEach(card => {
          const cardElement = document.createElement('div');
          cardElement.textContent = card.name;
          selectedDeckDisplay.appendChild(cardElement);
        });
        
        // Update lobby deck status
        if (document.getElementById('deckStatus')) {
          const deckStatus = document.getElementById('deckStatus');
          const deckCount = document.getElementById('deckCount');
          deckCount.textContent = selectedDeck.length;
          if (selectedDeck.length === 8) {
            deckStatus.innerHTML = 'Deck: Pronto (<span id="deckCount">8</span>/8 cartas)';
            deckStatus.style.color = '#00ff00';
          } else {
            deckStatus.innerHTML = 'Deck: N√£o pronto (<span id="deckCount">'+selectedDeck.length+'</span>/8 cartas)';
            deckStatus.style.color = '#ffff00';
          }
        }
      }
    }

    function startGame() {
      document.getElementById('towerCounter').textContent = `0/${maxTowers}`;
      clearInterval(gameLoop);
      enemies = [];
      towers = [];
      projectiles = [];
      gold = 8000;
      crystals = 0;
      lives = 20;
      wave = 0;
      generateWave();
      createTowerCards();
      gameContainer.style.display = 'flex';
      gameLoop = setInterval(update, 1000 / 60);
    }

    let currentCardIndex = 0;
    
    function createTowerCards() {
      const towerCardsContainer = document.getElementById('towerCards');
      towerCardsContainer.innerHTML = '';

      // Show only 4 cards at a time
      for (let i = 0; i < 4; i++) {
        const cardIndex = (currentCardIndex + i) % selectedDeck.length;
        const card = selectedDeck[cardIndex];
        
        const cardElement = document.createElement('div');
        cardElement.className = `tower-card ${card.rarity}`;
        cardElement.draggable = true;
        cardElement.innerHTML = `
          <div class="tower-card-name">${card.name}</div>
          <div class="tower-card-rarity ${card.rarity}">${card.rarity.toUpperCase()}</div>
          <div class="tower-card-cost"><span class="resource-icon gold-icon"></span> ${card.manaCost}</div>
          <div class="tower-card-description">${card.description}</div>
          <div class="tower-card-mana-cost"></div>
        `;
        cardElement.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', card.type);
          // After dragging, rotate the deck
          setTimeout(() => {
            currentCardIndex = (currentCardIndex + 1) % selectedDeck.length;
            createTowerCards();
          }, 0);
        });
        towerCardsContainer.appendChild(cardElement);
      }
    }

    function backToLobby() {
      gameContainer.style.display = 'none';
      clearInterval(gameLoop);
      enemies = [];
      towers = [];
      projectiles = [];
      gold = 300;
      crystals = 0;
      lives = 20;
      wave = 0;
      lobby.style.display = 'flex';
    }

    setTimeout(() => {
      loadingScreen.style.display = 'none';
      lobby.style.display = 'flex';
    }, 3000);

    document.getElementById('battleButton').addEventListener('click', () => {
      if (selectedDeck.length === 8) {
        lobby.style.display = 'none';
        startGame();
      } else {
        const message = document.getElementById('gameMessage');
        message.textContent = 'Por favor, monte seu deck primeiro na se√ß√£o Deck antes de jogar!';
        message.style.display = 'block';
        setTimeout(() => {
          message.style.display = 'none';
        }, 3000);
      }
    });
    
    document.getElementById('deckButton').addEventListener('click', () => {
      lobby.style.display = 'none';
      selectDeck();
    });
    
    document.getElementById('shopButton').addEventListener('click', () => {
      alert('Loja em desenvolvimento!');
    });
    
    document.getElementById('newsButton').addEventListener('click', () => {
      const newsContent = `
        <div id="newsModal" style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999; display:flex; justify-content:center; align-items:center;">
          <div style="background:#111; border:2px solid #00ff00; border-radius:10px; padding:20px; max-width:800px; max-height:80vh; overflow-y:auto;">
            <h2 style="color:#00ff00; text-align:center;">Atualiza√ß√µes do Jyter 0.4.8</h2>
            
            <h3 style="color:#ffff00;">Novidades:</h3>
            <ul style="color:#00ffff;">
              <li>Sistema de Mana completamente reformulado</li>
              <li>Novas torres lend√°rias adicionadas</li>
              <li>Efeitos visuais melhorados</li>
              <li>Balanceamento de dificuldade</li>
            </ul>

            <h3 style="color:#ffff00;">Torres Adicionadas:</h3>
            <ul style="color:#00ffff;">
              <li>Torre de Repuls√£o - Empurra inimigos para tr√°s</li>
              <li>Torre de Rodas - Torre m√≥vel que persegue inimigos</li>
              <li>Torre de Fogo - Dano em √°rea com efeitos de queimadura</li>
            </ul>

            <h3 style="color:#ffff00;">Melhorias:</h3>
            <ul style="color:#00ffff;">
              <li>Performance otimizada</li>
              <li>Interface do usu√°rio aprimorada</li>
              <li>Sistema de ondas rebalanceado</li>
              <li>Efeitos sonoros adicionados</li>
            </ul>

            <div style="text-align:center; margin-top:20px;">
              <button id="closeNews" style="background:#00ff00; color:#000; border:none; padding:10px 20px; cursor:pointer;">Fechar</button>
            </div>
          </div>
        </div>
      `;
      
      document.body.insertAdjacentHTML('beforeend', newsContent);
      document.getElementById('closeNews').addEventListener('click', () => {
        document.getElementById('newsModal').remove();
        lobby.style.display = 'flex';
      });
    });

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const waveInfoElement = document.getElementById('waveInfo');
    const resourceInfoElement = document.getElementById('resourceInfo');
    const backgroundCanvas = document.getElementById('backgroundCanvas');
    const bgCtx = backgroundCanvas.getContext('2d');
    const upgradeModal = document.getElementById('upgradeModal');
    const upgradeOptions = document.getElementById('upgradeOptions');
    const closeUpgradeModal = document.getElementById('closeUpgradeModal');
    const speedToggle = document.getElementById('speedToggle');
    const pauseMenu = document.getElementById('pauseMenu');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalWave = document.getElementById('finalWave');
    const backToDeckButton = document.getElementById('backToDeckButton');
    const removeTowerButton = document.getElementById('removeTowerButton');
    let isPaused = false;
    let isRemovingTower = false;
    
    document.getElementById('removeTowerButton').addEventListener('click', () => {
      if (mana >= 3) {
        isRemovingTower = !isRemovingTower;
        document.getElementById('removeTowerButton').classList.toggle('active', isRemovingTower);
      } else {
        const message = document.getElementById('gameMessage');
        message.textContent = 'Mana insuficiente para remover torres!';
        message.style.display = 'block';
        setTimeout(() => {
          message.style.display = 'none';
        }, 2000);
      }
    });

    backgroundCanvas.width = window.innerWidth;
    backgroundCanvas.height = window.innerHeight;

    let gameLoop;
    let enemies = [];
    let towers = [];
    let projectiles = [];
    let crystals = 0;
    let wave = 0;
    let waveEnemies = [];
    let enemiesSpawned = 0;
    let selectedTowerType = null;
    let selectedTower = null;
    let gameSpeed = 1;

    const enemyPath = [
      { x: -50, y: 100 },
      { x: 80, y: 100 },
      { x: 80, y: 250 },
      { x: 200, y: 250 },
      { x: 200, y: 50 },
      { x: 350, y: 50 },
      { x: 350, y: 300 },
      { x: 500, y: 300 },
      { x: 500, y: 100 },
      { x: 650, y: 100 },
      { x: 650, y: 250 },
      { x: 800, y: 250 },
      { x: 800, y: 150 },
      { x: 950, y: 150 },
      { x: 950, y: 300 },
      { x: 1100, y: 300 }
    ];

    function drawBackground() {
      const gradient = bgCtx.createLinearGradient(0, 0, backgroundCanvas.width, backgroundCanvas.height);
      gradient.addColorStop(0, '#0c0c2c');
      gradient.addColorStop(1, '#2c0c3c');
      bgCtx.fillStyle = gradient;
      bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);

      for (let i = 0; i < 50; i++) {
        bgCtx.beginPath();
        bgCtx.arc(
          Math.random() * backgroundCanvas.width,
          Math.random() * backgroundCanvas.height,
          Math.random() * 50,
          0,
          Math.PI * 2
        );
        bgCtx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.1)`;
        bgCtx.fill();
      }

      for (let i = 0; i < 20; i++) {
        bgCtx.beginPath();
        bgCtx.moveTo(Math.random() * backgroundCanvas.width, Math.random() * backgroundCanvas.height);
        bgCtx.lineTo(Math.random() * backgroundCanvas.width, Math.random() * backgroundCanvas.height);
        bgCtx.strokeStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.2)`;
        bgCtx.lineWidth = Math.random() * 3;
        bgCtx.stroke();
      }
    }

    drawBackground();

    class Enemy {
      constructor(type, wave) {
        this.x = enemyPath[0].x;
        this.y = enemyPath[0].y;
        this.pathIndex = 0;
        this.type = type;
        this.wave = wave;
        this.animationFrame = 0;
        this.animationSpeed = 0.1;
        this.damage = 1;
        this.attackCooldown = 60;
        this.attackCooldownRemaining = 0;
        this.attackCount = 0;
        this.goldReward = 10;
        this.slowed = false;
        this.slowDuration = 0;
        this.stunned = false;
        this.stunnedDuration = 0;

        const baseDifficulty = 1 + (wave * 0.1);

        switch (type) {
          case 'normal':
            this.speed = 1 * baseDifficulty;
            this.maxHealth = 100 * baseDifficulty;
            this.size = 30;
            this.color = '#ff5555';
            break;
          case 'fast':
            this.speed = 2 * baseDifficulty;
            this.maxHealth = 50 * baseDifficulty;
            this.size = 24;
            this.color = '#ffff55';
            break;
          case 'tank':
            this.speed = 0.5 * baseDifficulty;
            this.maxHealth = 200 * baseDifficulty;
            this.size = 40;
            this.color = '#aa55ff';
            break;
          case 'boss':
            this.speed = 0.3 * baseDifficulty;
            this.maxHealth = 2000 * baseDifficulty;
            this.size = 180;
            this.color = '#ff0000';
            this.damage = 1;
            this.attackCooldown = 60;
            this.attackCount = 0;
            this.pulsePhase = 0;
            this.pulseSize = 0;
            break;
        }

        this.health = this.maxHealth;
      }

      move() {
        if (this.type === 'boss') {
          this.pulsePhase += 0.05;
          this.pulseSize = Math.sin(this.pulsePhase) * 10;
        }
        
        if (this.stunned) {
          this.stunnedDuration--;
          if (this.stunnedDuration <= 0) {
            this.stunned = false;
          }
          return false;
        }

        const target = enemyPath[this.pathIndex];
        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < this.speed) {
          this.pathIndex++;
          if (this.pathIndex >= enemyPath.length) {
            lives--;
            enemyPassedCastle();
            if (lives <= 0) {
              endGame();
            }
            return true;
          }
        } else {
          const moveSpeed = this.slowed ? this.speed * 0.5 : this.speed;
          this.x += (dx / distance) * moveSpeed;
          this.y += (dy / distance) * moveSpeed;
        }

        this.animationFrame += this.animationSpeed;
        if (this.animationFrame >= 4) {
          this.animationFrame = 0;
        }

        if (this.health <= 0) {
          if (this.type === 'boss') {
            gold += 500;
            updateResourceInfo();
          }
          return true;
        }

        return false;
      }

      attack(towers) {
        if (this.type === 'boss' && this.attackCooldownRemaining <= 0) {
          for (let tower of towers) {
            const dx = tower.x - this.x;
            const dy = tower.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= 50) {
              tower.takeDamage(this.damage);
              this.attackCount++;
              if (this.attackCount >= 5) {
                tower.health = 0;
                this.attackCount = 0;
              }
              this.attackCooldownRemaining = this.attackCooldown;
              break;
            }
          }
        }
        if (this.attackCooldownRemaining > 0) {
          this.attackCooldownRemaining--;
        }
      }

      draw() {
        // Corpo principal
        const gradient = ctx.createRadialGradient(
          this.x, this.y, this.size / 4,
          this.x, this.y, this.size / 2
        );
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(1, this.type === 'boss' ? '#000000' : this.color.replace('55', '33'));
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
        ctx.fill();

        // Detalhes do inimigo
        if (this.type === 'normal') {
          // Olhos
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(this.x - this.size/5, this.y - this.size/6, this.size/8, 0, Math.PI * 2);
          ctx.arc(this.x + this.size/5, this.y - this.size/6, this.size/8, 0, Math.PI * 2);
          ctx.fill();
          
          // Boca
          ctx.beginPath();
          ctx.arc(this.x, this.y + this.size/8, this.size/6, 0, Math.PI);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.stroke();
        } 
        else if (this.type === 'fast') {
          // Listras
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 2;
          for (let i = 0; i < 4; i++) {
            const angle = i * Math.PI/2 + this.animationFrame;
            ctx.beginPath();
            ctx.moveTo(
              this.x + Math.cos(angle) * this.size/3,
              this.y + Math.sin(angle) * this.size/3
            );
            ctx.lineTo(
              this.x + Math.cos(angle) * this.size/2,
              this.y + Math.sin(angle) * this.size/2
            );
            ctx.stroke();
          }
        }
        else if (this.type === 'tank') {
          // Armadura
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
          ctx.stroke();
          
          // Cruz
          ctx.beginPath();
          ctx.moveTo(this.x - this.size/3, this.y);
          ctx.lineTo(this.x + this.size/3, this.y);
          ctx.moveTo(this.x, this.y - this.size/3);
          ctx.lineTo(this.x, this.y + this.size/3);
          ctx.stroke();
        }
        else if (this.type === 'boss') {
          // Detalhes do chef√£o
          const spikes = 8;
          for (let i = 0; i < spikes; i++) {
            const angle = i * (Math.PI * 2 / spikes) + this.animationFrame;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(
              this.x + Math.cos(angle) * this.size/1.5,
              this.y + Math.sin(angle) * this.size/1.5
            );
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 5;
            ctx.stroke();
          }
          
          // Olho central
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size/4, 0, Math.PI * 2);
          ctx.fill();
          
          // Pupila
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size/8, 0, Math.PI * 2);
          ctx.fill();
          
          // Aura
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size/1.8, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
          ctx.lineWidth = 10;
          ctx.stroke();
        }

        // Barra de vida
        const healthBarWidth = this.type === 'boss' ? 60 : 30;
        const healthBarHeight = this.type === 'boss' ? 8 : 5;
        const healthPercentage = this.health / this.maxHealth;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(
          this.x - healthBarWidth/2, 
          this.y - this.size/2 - 15, 
          healthBarWidth, 
          healthBarHeight
        );

        const healthColor = healthPercentage > 0.6 ? '#00ff00' : 
                          healthPercentage > 0.3 ? '#ffff00' : '#ff0000';
        
        ctx.fillStyle = healthColor;
        ctx.fillRect(
          this.x - healthBarWidth/2, 
          this.y - this.size/2 - 15, 
          healthBarWidth * healthPercentage, 
          healthBarHeight
        );
        
        // Borda da barra de vida
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(
          this.x - healthBarWidth/2, 
          this.y - this.size/2 - 15, 
          healthBarWidth, 
          healthBarHeight
        );
      }
    }

    function endGame() {
      clearInterval(gameLoop);
      gameOverScreen.style.display = 'flex';
      finalWave.textContent = wave;
    }

    class Tower {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.level = 1;
        this.health = 100;
        this.rotation = 0;
        this.goldCollected = 0;
        this.isCloned = false;
        this.pulsePhase = 0;
        this.moveSpeed = 0;
        this.moveDirection = 0;
        this.originalX = x;
        this.originalY = y;
        this.targetEnemy = null;
        this.updateStats();
      }

      updateStats() {
        switch (this.type) {
          case 'basic':
            this.range = 120;
            this.damage = 10;
            this.cooldown = 60;
            this.cost = 50;
            this.color = '#5555ff';
            break;
          case 'rapid':
            this.range = 180;
            this.damage = 1.5;
            this.cooldown = 5;
            this.cost = 170;
            this.color = '#ff55aa';
            break;
          case 'sniper':
            this.range = 250;
            this.damage = 33.33;
            this.cooldown = 120;
            this.cost = 250;
            this.color = '#800080';
            break;
          case 'ice':
            this.range = 100; // Increased range
            this.damage = 100;
            this.cooldown = 1; // Faster cooldown
            this.cost = 360; // Adjusted cost
            this.slowFactor = 0.3; // Stronger slow
            this.slowDuration = 360; // Longer duration
            this.frostParticles = [];
            break;
          case 'laser':
            this.range = 80;
            this.damage = 2;
            this.cooldown = 1;
            this.cost = 360;
            this.color = '#FF0000';
            break;
          case 'cannon':
            this.range = 200;
            this.damage = 60;
            this.cooldown = 180;
            this.cost = 300;
            this.color = '#B22222';
            break;
          case 'area':
            this.range = 120;
            this.damage = 20 / 3;
            this.cooldown = 30;
            this.cost = 120;
            this.color = '#4CAF50';
            break;
          case 'chain':
            this.range = 180;
            this.damage = 0;
            this.cooldown = 30;
            this.cost = 150;
            this.color = '#808080';
            break;
          case 'bomb':
            this.range = 150;
            this.damage = 15;
            this.cooldown = 180;
            this.cost = 120;
            this.color = '#FF4500';
            break;
          case 'bazooka':
            this.range = 60;
            this.damage = 1000;
            this.cooldown = 1000;
            this.cost = 160;
            this.color = '#8B0000';
            break;
          case 'threeMages':
            this.range = 150;
            this.damage = 7.5;
            this.cooldown = 90;
            this.cost = 150;
            this.color = '#8A2BE2';
            this.mageIndex = 0;
            break;
          case 'teleport':
            this.range = 150;
            this.damage = 0;
            this.cooldown = 420; // 7 seconds * 60 FPS
            this.cost = 250;
            this.color = '#9932CC';
            break;
          case 'combat':
            this.range = 100;
            this.damage = 15;
            this.cooldown = 120;
            this.cost = 250;
            this.color = '#FF6347';
            break;
          case 'mortar':
            this.range = 300;
            this.damage = 33;
            this.cooldown = 180;
            this.cost = 300;
            this.color = '#8B4513';
            break;
          case 'tesla':
            this.range = 130; // Increased range
            this.damage = 30; // Double damage
            this.cooldown = 90; // Faster cooldown
            this.cost = 300; // Adjusted cost
            this.color = '#4B0082'; // Darker purple
            this.lightningColor = '#9370DB'; // Light purple for lightning
            this.sparkParticles = [];
            break;
          case 'superArrows':
            this.range = 150;
            this.damage = 20;
            this.cooldown = 270;
            this.cost = 170;
            this.subTowers = [
              { x: this.x - 20, y: this.y - 20 },
              { x: this.x + 20, y: this.y - 20 },
              { x: this.x, y: this.y + 20 }
            ];
            break;
          case 'clone':
            this.range = 0;
            this.damage = 0;
            this.cooldown = 0;
            this.cost = 250;
            this.color = '#FF1493';
            break;
          case 'goldCollector':
            this.range = 0;
            this.damage = 0;
            this.cooldown = 60;
            this.cost = 150;
            this.color = '#FFD700';
            break;
          case 'multiShot':
            this.range = 170;
            this.damage = 2.5;
            this.cooldown = 20;
            this.cost = 200;
            this.color = '#8B008B';
            break;
          case 'seismic':
            this.range = 100;
            this.damage = 10;
            this.cooldown = 90;
            this.cost = 220;
            this.color = '#8B4513';
            this.stunDuration = 60;
            break;
          case 'repulsao':
            this.range = 150;
            this.damage = 0;
            this.cooldown = 600;
            this.cost = 280;
            this.color = '#FF1493';
            break;
          case 'wheeled':
            this.range = 150;
            this.damage = 15;
            this.cooldown = 60;
            this.cost = 200;
            this.color = '#4B0082';
            this.moveSpeed = 5; 
            this.targetEnemy = null;
            break;
          case 'fragmentation':
            this.range = 150;
            this.damage = 20;
            this.cooldown = 90;
            this.cost = 250;
            this.color = '#8B008B';
            break;
          case 'fire':
            this.range = 140;
            this.damage = 30;
            this.cooldown = 120;
            this.cost = 300;
            this.color = '#FF4500';
            break;
          case 'poison':
            this.range = 100;
            this.damage = 0.;
            this.cooldown = 2;
            this.cost = 150;
            this.color = '#8B008B';
            break;
        }
        this.cooldownRemaining = 0;
      }

      takeDamage(damage) {
        this.health -= damage;
        if (this.health <= 0) {
          return true;
        }
        return false;
      }

      attack(enemies) {
        if (this.cooldownRemaining > 0) {
          this.cooldownRemaining--;
          return false;
        }

        if (this.type === 'goldCollector') {
          this.cooldownRemaining = this.cooldown;
          this.goldCollected += 2;
          gold += 2;
          updateResourceInfo();

          if (this.goldCollected >= 300) {
            return 'remove';
          }
          return true;
        }

        if (this.type === 'combat') {
          let targets = enemies.filter(enemy => {
            const dx = enemy.x - this.x;
            const dy = enemy.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance <= this.range;
          }).slice(0, 2);

          targets.forEach(target => {
            projectiles.push(new Projectile(this.x, this.y, target, this.damage, this.type));
          });
          this.cooldownRemaining = this.cooldown;
          return true;
        }

        let targetEnemy = null;
        let closestDistance = Infinity;

        for (let enemy of enemies) {
          const dx = enemy.x - this.x;
          const dy = enemy.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance <= this.range && distance < closestDistance) {
            targetEnemy = enemy;
            closestDistance = distance;
          }
        }

        if (targetEnemy) {
          this.cooldownRemaining = this.cooldown;
          this.rotation = Math.atan2(targetEnemy.y - this.y, targetEnemy.x - this.x);

          switch (this.type) {
            case 'basic':
            case 'rapid':
            case 'sniper':
            case 'cannon':
            case 'area':
            case 'bomb':
            case 'bazooka':
            case 'teleport':
              projectiles.push(new Projectile(this.x, this.y, targetEnemy, this.damage, this.type));
              break;
            case 'threeMages':
              const angle = (this.mageIndex * 2 * Math.PI / 3);
              const mageX = this.x + Math.cos(angle) * 15;
              const mageY = this.y + Math.sin(angle) * 15;
              projectiles.push(new Projectile(mageX, mageY, targetEnemy, this.damage, this.type));
              this.mageIndex = (this.mageIndex + 1) % 3;
              this.cooldownRemaining = this.cooldown / 3;
              break;
            case 'ice':
              targetEnemy.slowed = true;
              targetEnemy.slowFactor = this.slowFactor;
              targetEnemy.slowDuration = this.slowDuration;
              break;
            case 'tesla':
              // Create spark particles
              for (let i = 0; i < 3; i++) {
                this.sparkParticles.push({
                  x: this.x + (Math.random() - 0.5) * 10,
                  y: this.y + (Math.random() - 0.5) * 10,
                  size: Math.random() * 3 + 1,
                  life: 10
                });
              }

              // Chain lightning effect
              let chainedEnemies = [];
              for (let enemy of enemies) {
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= this.range) {
                  enemy.health -= this.damage;
                  chainedEnemies.push(enemy);
                  
                  // Draw improved lightning
                  ctx.beginPath();
                  ctx.moveTo(this.x, this.y);
                  
                  const segments = 8;
                  for (let i = 1; i <= segments; i++) {
                    const t = i / segments;
                    const offset = (i % 2 === 0 ? 1 : -1) * 15 * (1 - t);
                    const x = this.x + dx * t + (Math.random() - 0.5) * offset;
                    const y = this.y + dy * t + (Math.random() - 0.5) * offset;
                    ctx.lineTo(x, y);
                  }
                  
                  ctx.lineTo(enemy.x, enemy.y);
                  ctx.strokeStyle = this.lightningColor;
                  ctx.lineWidth = 3;
                  ctx.shadowColor = this.lightningColor;
                  ctx.shadowBlur = 15;
                  ctx.stroke();
                  ctx.shadowBlur = 0;
                  
                  // Add glow effect at impact point
                  ctx.beginPath();
                  ctx.arc(enemy.x, enemy.y, 10, 0, Math.PI * 2);
                  ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                  ctx.fill();
                }
              }
              
              // Chain lightning between enemies
              for (let i = 0; i < chainedEnemies.length - 1; i++) {
                const e1 = chainedEnemies[i];
                const e2 = chainedEnemies[i+1];
                const dx = e2.x - e1.x;
                const dy = e2.y - e1.y;
                
                ctx.beginPath();
                ctx.moveTo(e1.x, e1.y);
                
                const segments = 5;
                for (let j = 1; j <= segments; j++) {
                  const t = j / segments;
                  const offset = (j % 2 === 0 ? 1 : -1) * 10 * (1 - t);
                  const x = e1.x + dx * t + (Math.random() - 0.5) * offset;
                  const y = e1.y + dy * t + (Math.random() - 0.5) * offset;
                  ctx.lineTo(x, y);
                }
                
                ctx.lineTo(e2.x, e2.y);
                ctx.strokeStyle = '#ADD8E6';
                ctx.lineWidth = 2;
                ctx.stroke();
              }
              break;
            case 'chain':
              targetEnemy.speed *= 0.9;
              targetEnemy.health -= this.damage;
              ctx.beginPath();
              ctx.moveTo(this.x, this.y);
              ctx.lineTo(targetEnemy.x, targetEnemy.y);
              ctx.strokeStyle = '#808080';
              ctx.lineWidth = 2;
              ctx.setLineDash([5, 3]);
              ctx.stroke();
              ctx.setLineDash([]);
              break;
            case 'superArrows':
              this.subTowers.forEach(subTower => {
                const subTargetEnemy = enemies.find(enemy => {
                  const dx = enemy.x - subTower.x;
                  const dy = enemy.y - subTower.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  return distance <= this.range;
                });
                if (subTargetEnemy) {
                  projectiles.push(new Projectile(subTower.x, subTower.y, subTargetEnemy, this.damage, this.type));
                }
              });
              break;
            case 'mortar':
              projectiles.push(new Projectile(this.x, this.y, targetEnemy, this.damage, this.type));
              break;
            case 'multiShot':
              let targets = enemies.filter(enemy => {
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance <= this.range;
              }).slice(0, 3);

              targets.forEach(target => {
                projectiles.push(new Projectile(this.x, this.y, target, this.damage, this.type));
              });
              break;
            case 'seismic':
              let stunned = false;
              for (let enemy of enemies) {
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= this.range) {
                  enemy.health -= this.damage;
                  if (!stunned) {
                    enemy.stunned = true;
                    enemy.stunnedDuration = this.stunDuration;
                    stunned = true;
                  }
                }
              }
              break;
            case 'repulsao':
              for (let enemy of enemies) {
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= this.range) {
                  enemy.pathIndex = Math.max(0, enemy.pathIndex - 1);
                  const targetPoint = enemyPath[enemy.pathIndex];
                  enemy.x += (targetPoint.x - enemy.x) * 0.2; 
                  enemy.y += (targetPoint.y - enemy.y) * 0.2;
                  break; 
                }
              }
              break;
            case 'wheeled':
              if (this.targetEnemy && this.targetEnemy.health <= 0) {
                this.targetEnemy = null;
              }
              if (!this.targetEnemy) {
                this.targetEnemy = enemies.find(enemy => {
                  const dx = enemy.x - this.x;
                  const dy = enemy.y - this.y;
                  return Math.sqrt(dx * dx + dy * dy) <= this.range;
                });
              }
              if (this.targetEnemy) {
                const dx = this.targetEnemy.x - this.x;
                const dy = this.targetEnemy.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 5) {
                  this.x += (dx / distance) * this.moveSpeed;
                  this.y += (dy / distance) * this.moveSpeed;
                }
                projectiles.push(new Projectile(this.x, this.y, this.targetEnemy, this.damage, this.type));
              } else {
                const dx = this.originalX - this.x;
                const dy = this.originalY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 5) {
                  this.x += (dx / distance) * this.moveSpeed;
                  this.y += (dy / distance) * this.moveSpeed;
                }
              }
              break;
            case 'fragmentation':
              projectiles.push(new Projectile(this.x, this.y, targetEnemy, this.damage, this.type));
              break;
            case 'fire':
              projectiles.push(new Projectile(this.x, this.y, targetEnemy, this.damage, this.type));
              break;
            case 'poison':
              for (let enemy of enemies) {
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= this.range) {
                  enemy.health -= this.damage;
                }
              }
              break;
          }
          return true;
        }

        return false;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.stroke();

        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
        ctx.fill();

        switch(this.type) {
          case 'superArrows':
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
            ctx.fill();
            this.subTowers.forEach(subTower => {
              ctx.beginPath();
              ctx.arc(subTower.x, subTower.y, 10, 0, Math.PI * 2);
              ctx.fillStyle = '#FFD700';
              ctx.fill();
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 2;
              ctx.stroke();
            });
            break;
          case 'threeMages':
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
            ctx.fill();
            for (let i = 0; i < 3; i++) {
              const angle = (i * 2 * Math.PI / 3) + (this.mageIndex * 2 * Math.PI / 3);
              const mageX = this.x + Math.cos(angle) * 15;
              const mageY = this.y + Math.sin(angle) * 15;
              ctx.beginPath();
              ctx.arc(mageX, mageY, 8, 0, Math.PI * 2);
              ctx.fillStyle = ['#FF4500', '#4169E1', '#32CD32'][i];
              ctx.fill();
            }
            break;
          case 'fragmentation':
            drawFragmentationDetails(this.x, this.y);
            break;
          case 'fire':
            drawFireDetails(this.x, this.y);
            break;
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = '#333333';
        ctx.fillRect(0, -4, 25, 8);
        ctx.restore();

        if (this.isCloned) {
          this.pulsePhase += 0.1;
          const pulseFactor = Math.sin(this.pulsePhase) * 0.2 + 0.8;
          ctx.strokeStyle = `rgba(0, 255, 255, ${pulseFactor})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(this.x, this.y, 22, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
    }

    function drawFragmentationDetails(x, y) {
      ctx.beginPath();
      ctx.arc(x, y, 15, 0, Math.PI * 2);
      ctx.fillStyle = '#8B008B';
      ctx.fill();
      ctx.strokeStyle = '#FFFFFF';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const angle = i * Math.PI / 4;
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * 20, y + Math.sin(angle) * 20);
      }
      ctx.stroke();
    }

    function drawFireDetails(x, y) {
      ctx.beginPath();
      ctx.arc(x, y, 15, 0, Math.PI * 2);
      ctx.fillStyle = '#FF4500';
      ctx.fill();
      const flameHeight = 10 + Math.sin(Date.now() / 200) * 5;
      ctx.beginPath();
      ctx.moveTo(x - 10, y - 10);
      ctx.quadraticCurveTo(x - 5, y - 20 - flameHeight, x, y - 10);
      ctx.quadraticCurveTo(x + 5, y - 20 - flameHeight, x + 10, y - 10);
      ctx.fillStyle = '#FFFF00';
      ctx.fill();
    }

    class Projectile {
      constructor(x, y, target, damage, type, speed = 5) {
        this.x = x;
        this.y = y;
        this.target = target;
        this.damage = damage;
        this.type = type;
        this.speed = speed;
        this.explosionCount = type === 'bomb' ? 3 : 0;
        this.isMortarStone = type === 'mortar';
      }

      move() {
        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < this.speed) {
          switch (this.type) {
            case 'teleport':
              this.target.x = enemyPath[0].x;
              this.target.y = enemyPath[0].y;
              this.target.pathIndex = 0;
              break;
            case 'area':
              for (let enemy of enemies) {
                const enemyDx = enemy.x - this.target.x;
                const enemyDy = enemy.y - this.target.y;
                const enemyDistance = Math.sqrt(enemyDx * enemyDx + enemyDy * enemyDy);
                if (enemyDistance <= 50) {
                  enemy.health -= this.damage;
                }
              }
              break;
            case 'bomb':
              if (this.explosionCount > 0) {
                this.explosionCount--;
                for (let enemy of enemies) {
                  const enemyDx = enemy.x - this.target.x;
                  const enemyDy = enemy.y - this.target.y;
                  const enemyDistance = Math.sqrt(enemyDx * enemyDx + enemyDy * enemyDy);
                  if (enemyDistance <= 30) {
                    enemy.health -= this.damage;
                  }
                }
                return false;
              }
              break;
            case 'fragmentation':
              this.target.health -= this.damage;
              for (let i = 0; i < 6; i++) {
                const angle = Math.random() * Math.PI * 2;
                const fragment = new Projectile(this.target.x, this.target.y, {x: this.target.x + Math.cos(angle) * 50, y: this.target.y + Math.sin(angle) * 50}, this.damage / 3, 'fragment');
                fragment.speed = 3;
                projectiles.push(fragment);
              }
              break;
            case 'fire':
              for (let enemy of enemies) {
                const dx = enemy.x - this.target.x;
                const dy = enemy.y - this.target.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= 50) {
                  enemy.health -= this.damage;
                }
              }
              break;
            case 'fragment':
              break;
            default:
              this.target.health -= this.damage;
              break;
          }

          if (this.target.health <= 0) {
            gold += 10;
            updateResourceInfo();
          }
          return true;
        }

        this.x += (dx / distance) * this.speed;
        this.y += (dy / distance) * this.speed;
        return false;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(Math.atan2(this.target.y - this.y, this.target.x - this.x));

        switch (this.type) {
          case 'bomb':
            ctx.fillStyle = '#FF4500';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, -8);
            ctx.lineTo(5, -13);
            ctx.lineTo(8, -10);
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.stroke();
            break;
          case 'bazooka':
            ctx.fillStyle = '#8B0000';
            ctx.beginPath();
            ctx.moveTo(-8, -4);
            ctx.lineTo(8, 0);
            ctx.lineTo(-8, 4);
            ctx.closePath();
            ctx.fill();
            break;
          case 'threeMages':
            ctx.fillStyle = ['#FF4500', '#4169E1', '#32CD32'][this.mageIndex % 3];
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'teleport':
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#9932CC';
            ctx.lineWidth = 2;
            ctx.stroke();
            break;
          case 'combat':
            ctx.fillStyle = '#FF6347';
            ctx.beginPath();
            ctx.moveTo(-5, -5);
            ctx.lineTo(5, 0);
            ctx.lineTo(-5, 5);
            ctx.closePath();
            ctx.fill();
            break;
          case 'mortar':
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#A0522D';
            ctx.lineWidth = 2;
            ctx.stroke();
            break;
          case 'fragmentation':
            ctx.fillStyle = '#8B008B';
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'fire':
            ctx.fillStyle = '#FF4500';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFF00';
            ctx.beginPath();
            ctx.moveTo(-6, -6);
            ctx.lineTo(0, -12);
            ctx.lineTo(6, -6);
            ctx.closePath();
            ctx.fill();
            break;
          default:
            ctx.fillStyle = this.getProjectileColor();
            ctx.beginPath();
            ctx.arc(0, 0, this.getProjectileSize(), 0, Math.PI * 2);
            ctx.fill();
            break;
        }

        ctx.restore();
      }

      getProjectileColor() {
        switch (this.type) {
          case 'bomb': return '#FF4500';
          case 'bazooka': return '#8B0000';
          case 'threeMages': return '#8A2BE2';
          case 'teleport': return '#FFFFFF';
          case 'combat': return '#FF6347';
          case 'mortar': return '#8B4513';
          default: return '#ffffff';
        }
      }

      getProjectileSize() {
        switch (this.type) {
          case 'bomb': return 6;
          case 'bazooka': return 8;
          case 'threeMages': return 4;
          case 'teleport': return 5;
          case 'combat': return 5;
          case 'mortar': return 8;
          default: return 3;
        }
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      createTowerCards();
      gameContainer.style.display = 'none';
      updateResourceInfo();
    });

    canvas.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    function isPositionOnPath(x, y) {
      // Check if position is too close to path
      const pathWidth = 30; // Width of the path
      
      for (let i = 0; i < enemyPath.length - 1; i++) {
        const start = enemyPath[i];
        const end = enemyPath[i+1];
        
        // Simple line segment distance check
        const lineLength = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
        const t = Math.max(0, Math.min(1, ((x - start.x) * (end.x - start.x) + (y - start.y) * (end.y - start.y)) / Math.pow(lineLength, 2)));
        const projX = start.x + t * (end.x - start.x);
        const projY = start.y + t * (end.y - start.y);
        const dist = Math.sqrt(Math.pow(x - projX, 2) + Math.pow(y - projY, 2));
        
        if (dist < pathWidth) {
          return true;
        }
      }
      return false;
    }

    canvas.addEventListener('click', (e) => {
      if (isRemovingTower) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Find closest tower
        let closestTower = null;
        let minDistance = Infinity;
        
        towers.forEach(tower => {
          const dx = tower.x - x;
          const dy = tower.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < minDistance && distance < 30) { // 30px click radius
            minDistance = distance;
            closestTower = tower;
          }
        });
        
        if (closestTower) {
          towers = towers.filter(t => t !== closestTower);
          mana -= 3;
          updateResourceInfo();
          document.getElementById('towerCounter').textContent = `${towers.length}/${maxTowers}`;
        }
        
        // Turn off removal mode after use
        isRemovingTower = false;
        document.getElementById('removeTowerButton').classList.remove('active');
      }
    });

    canvas.addEventListener('drop', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const cardType = e.dataTransfer.getData('text');

      const card = selectedDeck.find(c => c.type === cardType);
      if (!card) return;

      const manaCost = card.manaCost;
      // Skip path check for spells (except towers)
      if (!spells.some(s => s.type === card.type) && isPositionOnPath(x, y)) {
        const message = document.getElementById('gameMessage');
        message.textContent = 'N√£o pode colocar torres no caminho dos inimigos!';
        message.style.display = 'block';
        setTimeout(() => {
          message.style.display = 'none';
        }, 2000);
        return;
      }
      if (card && mana >= manaCost) {
        // Only check tower limit for actual towers, not spells
        if (!spells.some(s => s.type === card.type) && towers.length >= maxTowers) {
          const message = document.getElementById('gameMessage');
          message.textContent = 'Limite de 7 torres atingido!';
          message.style.display = 'block';
          setTimeout(() => {
            message.style.display = 'none';
          }, 2000);
          return;
        }
        document.getElementById('towerCounter').textContent = `${towers.length + 1}/${maxTowers}`;
        if (card.type === 'tornado') {
          castTornado(x, y);
          mana -= manaCost;
          updateResourceInfo();
        } else if (card.type === 'blackhole') {
          castBlackHole(x, y);
          mana -= manaCost;
          updateResourceInfo();
        } else if (card.type === 'vacuum') {
          castVacuum(x, y);
          mana -= manaCost;
          updateResourceInfo();
        } else if (card.type === 'spacetime') {
          castSpacetime(x, y);
          mana -= manaCost;
          updateResourceInfo();
        } else if (card.type === 'meteor') {
          castMeteorShower(x, y);
          mana -= manaCost;
          updateResourceInfo();
        } else if (card.type === 'barreira') {
          castBarreira(x, y);
          mana -= manaCost;
          updateResourceInfo();
        } else if (card.type === 'cemiterio') {
          castCemiterio(x, y);
          mana -= manaCost;
          updateResourceInfo();
        } else if (card.type === 'terraqueimada') {
          castTerraQueimada(x, y);
          mana -= manaCost;
          updateResourceInfo();
        } else if (card.type === 'tempestadeeletrica') {
          castTempestadeEletrica(x, y);
          mana -= manaCost;
          updateResourceInfo();
        } else if (card.type === 'furia') {
          // Find closest tower to click position
          let closestTower = null;
          let minDistance = Infinity;
          towers.forEach(tower => {
            const dx = tower.x - x;
            const dy = tower.y - y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < minDistance) {
              minDistance = distance;
              closestTower = tower;
            }
          });
          
          if (closestTower && minDistance < 100) { // 100px radius to select tower
            castFuria(closestTower);
            mana -= manaCost;
            updateResourceInfo();
          } else {
            const message = document.getElementById('gameMessage');
            message.textContent = 'Nenhuma torre pr√≥xima encontrada!';
            message.style.display = 'block';
            setTimeout(() => {
              message.style.display = 'none';
            }, 2000);
          }
        } else if (card.type === 'clone') {
          // Find closest tower to click position
          let closestTower = null;
          let minDistance = Infinity;
          towers.forEach(tower => {
            const dx = tower.x - x;
            const dy = tower.y - y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < minDistance) {
              minDistance = distance;
              closestTower = tower;
            }
          });
          
          if (closestTower && minDistance < 100) { // 100px radius to select tower
            castClone(closestTower);
            mana -= manaCost;
            updateResourceInfo();
          } else {
            const message = document.getElementById('gameMessage');
            message.textContent = 'Nenhuma torre pr√≥xima encontrada!';
            message.style.display = 'block';
            setTimeout(() => {
              message.style.display = 'none';
            }, 2000);
          }
        } else {
          if (towers.length >= maxTowers) {
            const message = document.getElementById('gameMessage');
            message.textContent = 'Limite de 7 torres atingido!';
            message.style.display = 'block';
            setTimeout(() => {
              message.style.display = 'none';
            }, 2000);
            return;
          }
          towers.push(new Tower(x, y, card.type));
          mana -= manaCost;
          updateResourceInfo();
        }
      } else {
        const message = document.getElementById('gameMessage');
        message.textContent = 'Mana insuficiente para usar este card!';
        message.style.display = 'block';
        setTimeout(() => {
          message.style.display = 'none';
        }, 2000);
      }
    });

    function castCemiterio(x, y) {
      const duration = 540; // 9 segundos em frames (60fps)
      const numTowers = 5;
      const ghostTowers = [];
      
      // Criar torres fantasmas
      for (let i = 0; i < numTowers; i++) {
        const angle = (i * (2 * Math.PI / numTowers)) + (Math.random() * 0.5);
        const radius = 30 + Math.random() * 20;
        const towerX = x + Math.cos(angle) * radius;
        const towerY = y + Math.sin(angle) * radius;
        
        ghostTowers.push({
          x: towerX,
          y: towerY,
          originalX: towerX,
          originalY: towerY,
          targetEnemy: null,
          moveSpeed: 2,
          range: 100,
          damage: 8,
          cooldown: 30,
          cooldownRemaining: 0,
          duration: duration,
          particles: []
        });
      }

      function updateGhostTowers() {
        // Atualizar e desenhar torres fantasmas
        ghostTowers.forEach((tower, index) => {
          tower.duration--;
          
          if (tower.duration <= 0) {
            // Efeito de desaparecimento
            if (tower.duration > -30) {
              const alpha = (tower.duration + 30) / 30;
              drawGhostTower(tower, alpha);
            }
            return;
          }

          // L√≥gica de movimento
          if (tower.targetEnemy && tower.targetEnemy.health <= 0) {
            tower.targetEnemy = null;
          }
          
          if (!tower.targetEnemy) {
            // Encontrar novo alvo
            tower.targetEnemy = enemies.find(enemy => {
              const dx = enemy.x - tower.x;
              const dy = enemy.y - tower.y;
              return Math.sqrt(dx * dx + dy * dy) <= tower.range;
            });
          }
          
          if (tower.targetEnemy) {
            // Mover em dire√ß√£o ao alvo
            const dx = tower.targetEnemy.x - tower.x;
            const dy = tower.targetEnemy.y - tower.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
              tower.x += (dx / distance) * tower.moveSpeed;
              tower.y += (dy / distance) * tower.moveSpeed;
            }
          } else {
            // Voltar para posi√ß√£o original
            const dx = tower.originalX - tower.x;
            const dy = tower.originalY - tower.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
              tower.x += (dx / distance) * tower.moveSpeed * 0.5;
              tower.y += (dy / distance) * tower.moveSpeed * 0.5;
            }
          }
          
          // L√≥gica de ataque
          if (tower.cooldownRemaining <= 0 && tower.targetEnemy) {
            const dx = tower.targetEnemy.x - tower.x;
            const dy = tower.targetEnemy.y - tower.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= tower.range) {
              // Criar proj√©til
              ctx.beginPath();
              ctx.moveTo(tower.x, tower.y);
              ctx.lineTo(tower.targetEnemy.x, tower.targetEnemy.y);
              ctx.strokeStyle = 'rgba(100, 255, 100, 0.7)';
              ctx.lineWidth = 2;
              ctx.stroke();
              
              // Efeito de part√≠cula
              for (let i = 0; i < 3; i++) {
                tower.particles.push({
                  x: tower.x,
                  y: tower.y,
                  vx: (Math.random() - 0.5) * 2,
                  vy: (Math.random() - 0.5) * 2,
                  size: 2 + Math.random() * 3,
                  life: 20
                });
              }
              
              tower.targetEnemy.health -= tower.damage;
              tower.cooldownRemaining = tower.cooldown;
            }
          } else {
            tower.cooldownRemaining--;
          }
          
          // Atualizar part√≠culas
          tower.particles.forEach((p, i) => {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) tower.particles.splice(i, 1);
          });
          
          // Desenhar torre
          drawGhostTower(tower, 1);
        });
        
        // Remover torres que terminaram
        for (let i = ghostTowers.length - 1; i >= 0; i--) {
          if (ghostTowers[i].duration <= -30) {
            ghostTowers.splice(i, 1);
          }
        }
        
        if (ghostTowers.length > 0) {
          requestAnimationFrame(updateGhostTowers);
        }
      }
      
      function drawGhostTower(tower, alpha) {
        // Corpo da torre
        ctx.fillStyle = `rgba(50, 150, 50, ${alpha * 0.7})`;
        ctx.beginPath();
        ctx.arc(tower.x, tower.y, 15, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = `rgba(100, 255, 100, ${alpha})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Alcance
        ctx.beginPath();
        ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(100, 255, 100, ${alpha * 0.2})`;
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Part√≠culas
        tower.particles.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(100, 255, 100, ${alpha * (p.life/20)})`;
          ctx.fill();
        });
      }
      
      updateGhostTowers();
    }

    function castBarreira(x, y) {
      const barreiraRadius = 80;
      const barreiraDuration = 540; // 9 segundos (60 FPS * 9)
      let remainingDuration = barreiraDuration;
      let barreiraActive = true;
      let barreiraX = x;
      let barreiraY = y;

      function updateBarreira() {
        if (!barreiraActive) return;

        // Desenha a barreira
        ctx.beginPath();
        ctx.arc(barreiraX, barreiraY, barreiraRadius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
        ctx.lineWidth = 5;
        ctx.stroke();
        
        // Desenha o preenchimento transparente
        ctx.fillStyle = 'rgba(0, 100, 255, 0.2)';
        ctx.fill();

        // Desenha o contador de tempo
        const secondsLeft = Math.ceil(remainingDuration / 60);
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${secondsLeft}s`, barreiraX, barreiraY + 5);

        // Bloqueia inimigos
        enemies.forEach(enemy => {
          const dx = enemy.x - barreiraX;
          const dy = enemy.y - barreiraY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance <= barreiraRadius + enemy.size/2) {
            // Empurra o inimigo para fora da barreira
            const pushDistance = barreiraRadius + enemy.size/2;
            const angle = Math.atan2(dy, dx);
            enemy.x = barreiraX + Math.cos(angle) * pushDistance;
            enemy.y = barreiraY + Math.sin(angle) * pushDistance;
          }
        });

        remainingDuration--;
        if (remainingDuration <= 0) {
          barreiraActive = false;
          // Efeito de desaparecimento
          let fadeDuration = 30;
          function fadeOut() {
            if (fadeDuration <= 0) return;
            
            ctx.beginPath();
            ctx.arc(barreiraX, barreiraY, barreiraRadius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(0, 255, 255, ${fadeDuration/30 * 0.7})`;
            ctx.lineWidth = 5;
            ctx.stroke();
            ctx.fillStyle = `rgba(0, 100, 255, ${fadeDuration/30 * 0.2})`;
            ctx.fill();
            
            fadeDuration--;
            if (fadeDuration > 0) {
              requestAnimationFrame(fadeOut);
            }
          }
          fadeOut();
        } else {
          requestAnimationFrame(updateBarreira);
        }
      }

      updateBarreira();
    }

    function castTornado(x, y) {
      const tornadoRadius = 100; // Smaller radius (2x smaller)
      const tornadoDuration = 360; // Longer duration (6 seconds)
      let remainingDuration = tornadoDuration;
      const particles = [];

      function updateTornado() {
        if (remainingDuration <= 0) return;

        // Create swirling particles
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: x + Math.cos(Date.now()/100 + i) * tornadoRadius * 0.8,
            y: y + Math.sin(Date.now()/100 + i) * tornadoRadius * 0.8,
            size: Math.random() * 15 + 5,
            life: 60
          });
        }

        // Draw tornado base
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, tornadoRadius);
        gradient.addColorStop(0, 'rgba(100, 100, 255, 0.8)');
        gradient.addColorStop(1, 'rgba(50, 50, 200, 0.2)');
        
        ctx.beginPath();
        ctx.arc(x, y, tornadoRadius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Draw swirling particles
        particles.forEach((p, i) => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(200, 200, 255, ${p.life/60})`;
          ctx.fill();
          p.life--;
          if (p.life <= 0) particles.splice(i, 1);
        });

        // Draw tornado spiral
        ctx.beginPath();
        for (let i = 0; i < 20; i++) {
          const angle = Date.now()/100 + i * 0.3;
          const radius = tornadoRadius * (i/20);
          const px = x + Math.cos(angle) * radius;
          const py = y + Math.sin(angle) * radius;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.lineWidth = 3;
        ctx.stroke();

        enemies.forEach(enemy => {
          const dx = enemy.x - x;
          const dy = enemy.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance <= tornadoRadius) {
            if (enemy.type !== 'boss') {
              enemy.x += (x - enemy.x) * 0.1;
              enemy.y += (y - enemy.y) * 0.1;
              if (remainingDuration === tornadoDuration) {
                enemy.health *= 0.5;
              }
            }
          }
        });

        remainingDuration--;
        if (remainingDuration > 0) {
          requestAnimationFrame(updateTornado);
        }
      }

      updateTornado();
    }

    function generateWave() {
      wave++;
      const bossWave = wave % 10 === 0;
      const enemiesPerWave = Math.floor((wave - 1) / 3) + 1;

      waveEnemies = [];
      if (bossWave) {
        waveEnemies.push(new Enemy('boss', wave));
      } else {
        for (let i = 0; i < enemiesPerWave; i++) {
          const randomValue = Math.random();
          let enemyType;
          if (randomValue < 0.6) {
            enemyType = 'normal';
          } else if (randomValue < 0.9) {
            enemyType = 'fast';
          } else {
            enemyType = 'tank';
          }
          waveEnemies.push(new Enemy(enemyType, wave));
        }
      }

      enemiesSpawned = 0;
      updateWaveInfo();
    }

    function updateWaveInfo() {
      waveInfoElement.textContent = `Onda: ${wave} | Inimigos: ${enemiesSpawned}/${waveEnemies.length} | Vidas: ${lives}`;
    }

    function updateResourceInfo() {
      const manaPercentage = (mana / maxMana) * 100;
      document.getElementById('manaText').textContent = `${mana.toFixed(1)}/${maxMana}`;
      document.getElementById('manaFill').style.width = `${manaPercentage}%`;
      
      // Atualiza a cor da barra conforme a mana diminui
      if (manaPercentage < 20) {
        document.getElementById('manaFill').style.background = 'linear-gradient(90deg, #ff0000, #ff6600)';
      } else if (manaPercentage < 50) {
        document.getElementById('manaFill').style.background = 'linear-gradient(90deg, #ff6600, #ffff00)';
      } else {
        document.getElementById('manaFill').style.background = 'linear-gradient(90deg, #0066ff, #00ffff)';
      }

      resourceInfoElement.innerHTML = `
        <span class="resource-icon crystal-icon">üíé</span> ${crystals}
        | ‚ù§Ô∏è ${lives}
      `;
    }

    function spawnEnemy() {
      if (enemiesSpawned < waveEnemies.length) {
        if (Math.random() < 0.05) {
          enemies.push(waveEnemies[enemiesSpawned]);
          enemiesSpawned++;
          updateWaveInfo();
        }
      } else if (enemies.length === 0) {
        generateWave();
        // No gold bonus, just mana regen
        if (wave % 5 === 0) {
          crystals += Math.floor(wave / 5);
        }
      }
    }

    function drawPath() {
      ctx.strokeStyle = '#aa5500';
      ctx.lineWidth = 30;
      ctx.beginPath();
      ctx.moveTo(enemyPath[0].x, enemyPath[0].y);
      for (let i = 1; i < enemyPath.length; i++) {
        ctx.lineTo(enemyPath[i].x, enemyPath[i].y);
      }
      ctx.stroke();
      
      // Draw path leading to castle gate
      ctx.beginPath();
      ctx.moveTo(enemyPath[enemyPath.length-1].x, enemyPath[enemyPath.length-1].y);
      ctx.lineTo(1100 + 100/2, 300); // Center of castle gate
      ctx.stroke();

      ctx.strokeStyle = '#cc7700';
      ctx.lineWidth = 2;
      for (let i = 0; i < enemyPath.length - 1; i++) {
        const startX = enemyPath[i].x;
        const startY = enemyPath[i].y;
        const endX = enemyPath[i + 1].x;
        const endY = enemyPath[i + 1].y;
        for (let j = 0; j < 10; j++) {
          const x1 = startX + (endX - startX) * (j / 10) + (Math.random() - 0.5) * 20;
          const y1 = startY + (endY - startY) * (j / 10) + (Math.random() - 0.5) * 20;
          const x2 = startX + (endX - startX) * ((j + 1) / 10) + (Math.random() - 0.5) * 20;
          const y2 = startY + (endY - startY) * ((j + 1) / 10) + (Math.random() - 0.5) * 20;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }
    }

    let castleParticles = [];
    let castleShake = 0;
    let lastEnemyPassedTime = 0;

    function drawCastle() {
      const castleX = 1100;
      const castleY = 300;
      const castleWidth = 200;
      const castleHeight = 200;
      
      // Apply shake effect
      const shakeX = castleShake > 0 ? (Math.random() - 0.5) * 10 : 0;
      const shakeY = castleShake > 0 ? (Math.random() - 0.5) * 10 : 0;
      
      // Main castle structure with gradient
      const gradient = ctx.createLinearGradient(castleX, castleY - castleHeight, castleX, castleY);
      gradient.addColorStop(0, '#5D4037');
      gradient.addColorStop(1, '#3E2723');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.moveTo(castleX + shakeX, castleY + shakeY);
      ctx.lineTo(castleX + castleWidth + shakeX, castleY + shakeY);
      ctx.lineTo(castleX + castleWidth + shakeX, castleY - castleHeight/2 + shakeY);
      ctx.lineTo(castleX + castleWidth/2 + 30 + shakeX, castleY - castleHeight + shakeY);
      ctx.lineTo(castleX + shakeX, castleY - castleHeight/2 + shakeY);
      ctx.closePath();
      ctx.fill();
      
      // Castle towers with details
      const towerGradient = ctx.createLinearGradient(0, 0, 0, 50);
      towerGradient.addColorStop(0, '#8D6E63');
      towerGradient.addColorStop(1, '#5D4037');
      
      // Left tower
      ctx.save();
      ctx.translate(castleX - 30 + shakeX, castleY - castleHeight - 50 + shakeY);
      ctx.fillStyle = towerGradient;
      ctx.beginPath();
      ctx.arc(0, 0, 40, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#4E342E';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Tower details
      for (let i = 0; i < 8; i++) {
        const angle = i * Math.PI/4;
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * 30, Math.sin(angle) * 30);
        ctx.lineTo(Math.cos(angle) * 40, Math.sin(angle) * 40);
        ctx.strokeStyle = '#4E342E';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      ctx.restore();
      
      // Right tower
      ctx.save();
      ctx.translate(castleX + castleWidth + 30 + shakeX, castleY - castleHeight - 50 + shakeY);
      ctx.fillStyle = towerGradient;
      ctx.beginPath();
      ctx.arc(0, 0, 40, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#4E342E';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Tower details
      for (let i = 0; i < 8; i++) {
        const angle = i * Math.PI/4;
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * 30, Math.sin(angle) * 30);
        ctx.lineTo(Math.cos(angle) * 40, Math.sin(angle) * 40);
        ctx.strokeStyle = '#4E342E';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      ctx.restore();
      
      // Center tower (bigger)
      ctx.save();
      ctx.translate(castleX + castleWidth/2 + shakeX, castleY - castleHeight - 80 + shakeY);
      ctx.fillStyle = towerGradient;
      ctx.beginPath();
      ctx.arc(0, 0, 60, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#4E342E';
      ctx.lineWidth = 4;
      ctx.stroke();
      
      // Tower details
      for (let i = 0; i < 12; i++) {
        const angle = i * Math.PI/6;
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * 45, Math.sin(angle) * 45);
        ctx.lineTo(Math.cos(angle) * 60, Math.sin(angle) * 60);
        ctx.strokeStyle = '#4E342E';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      
      // Tower flag
      ctx.fillStyle = '#D32F2F';
      ctx.beginPath();
      ctx.moveTo(0, -60);
      ctx.lineTo(20, -80);
      ctx.lineTo(40, -60);
      ctx.lineTo(20, -40);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#B71C1C';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Flag details
      ctx.fillStyle = '#FFEB3B';
      ctx.beginPath();
      ctx.arc(20, -60, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      
      // Castle battlements with depth
      ctx.fillStyle = '#6D4C41';
      for (let i = 0; i < 8; i++) {
        // Left side
        ctx.beginPath();
        ctx.moveTo(castleX + i*25 + shakeX, castleY - castleHeight/2 + shakeY);
        ctx.lineTo(castleX + i*25 + 10 + shakeX, castleY - castleHeight/2 - 10 + shakeY);
        ctx.lineTo(castleX + i*25 + 20 + shakeX, castleY - castleHeight/2 + shakeY);
        ctx.closePath();
        ctx.fill();
        
        // Right side
        ctx.beginPath();
        ctx.moveTo(castleX + castleWidth - i*25 + shakeX, castleY - castleHeight/2 + shakeY);
        ctx.lineTo(castleX + castleWidth - i*25 - 10 + shakeX, castleY - castleHeight/2 - 10 + shakeY);
        ctx.lineTo(castleX + castleWidth - i*25 - 20 + shakeX, castleY - castleHeight/2 + shakeY);
        ctx.closePath();
        ctx.fill();
      }
      
      // Castle gate with arch and details
      ctx.save();
      ctx.translate(castleX + castleWidth/2 + shakeX, castleY + shakeY);
      
      // Gate arch
      ctx.fillStyle = '#4E342E';
      ctx.beginPath();
      ctx.arc(0, -40, 40, 0, Math.PI);
      ctx.lineTo(-40, 0);
      ctx.lineTo(40, 0);
      ctx.closePath();
      ctx.fill();
      
      // Gate door
      ctx.fillStyle = '#3E2723';
      ctx.beginPath();
      ctx.arc(0, -40, 30, 0, Math.PI);
      ctx.lineTo(-30, 0);
      ctx.lineTo(30, 0);
      ctx.closePath();
      ctx.fill();
      
      // Door details
      ctx.strokeStyle = '#5D4037';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, -20, 10, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(-15, -30);
      ctx.lineTo(15, -30);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(-15, -10);
      ctx.lineTo(15, -10);
      ctx.stroke();
      ctx.restore();
      
      // Windows with stained glass effect
      const windowPositions = [
        {x: castleX + 40, y: castleY - 100},
        {x: castleX + castleWidth - 40, y: castleY - 100},
        {x: castleX + castleWidth/2, y: castleY - 150}
      ];
      
      windowPositions.forEach(pos => {
        ctx.save();
        ctx.translate(pos.x + shakeX, pos.y + shakeY);
        
        // Window frame
        ctx.fillStyle = '#4E342E';
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // Stained glass
        for (let i = 0; i < 8; i++) {
          const angle = i * Math.PI/4;
          ctx.fillStyle = `hsla(${i * 45}, 80%, 50%, 0.7)`;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.arc(0, 0, 12, angle, angle + Math.PI/4);
          ctx.closePath();
          ctx.fill();
        }
        
        // Window cross
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-12, 0);
        ctx.lineTo(12, 0);
        ctx.moveTo(0, -12);
        ctx.lineTo(0, 12);
        ctx.stroke();
        ctx.restore();
      });
      
      // Draw castle particles
      castleParticles.forEach((p, i) => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        
        p.x += p.vx;
        p.y += p.vy;
        p.size *= 0.95;
        p.life--;
        
        if (p.life <= 0) {
          castleParticles.splice(i, 1);
        }
      });
      
      // Reduce shake over time
      if (castleShake > 0) {
        castleShake--;
      }
    }

    function enemyPassedCastle() {
      const now = Date.now();
      if (now - lastEnemyPassedTime > 1000) { // Only trigger once per second max
        lastEnemyPassedTime = now;
        castleShake = 20;
        
        // Create explosion particles
        for (let i = 0; i < 50; i++) {
          castleParticles.push({
            x: 1100 + 100 + (Math.random() - 0.5) * 50,
            y: 300 + (Math.random() - 0.5) * 50,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            size: 5 + Math.random() * 10,
            life: 30 + Math.random() * 30,
            color: `hsla(${Math.random() * 30 + 10}, 100%, 50%, 0.8)`
          });
        }
      }
    }

    function update() {
      if (!isPaused) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        drawPath();
        drawCastle();
        
        for (let i = 0; i < gameSpeed; i++) {
          spawnEnemy();

          enemies = enemies.filter(enemy => {
            enemy.move();
            enemy.attack(towers);
            return enemy.health > 0 && enemy.pathIndex < enemyPath.length;
          });

          towers = towers.filter(tower => {
            const result = tower.attack(enemies);
            if (result === 'remove') {
              return false;
            }
            return true;
          });

          towers.forEach(tower => {
            tower.attack(enemies);
          });

          projectiles = projectiles.filter(projectile => {
            return !projectile.move();
          });


          if (enemies.length === 0 && enemiesSpawned >= waveEnemies.length) {
            generateWave();
          }
        }

        enemies.forEach(enemy => enemy.draw());
        towers.forEach(tower => tower.draw());
        projectiles.forEach(projectile => projectile.draw());

        // Regenerate mana
        mana = Math.min(maxMana, mana + manaRegenRate);
        updateResourceInfo();
        updateWaveInfo();
      }
    }

    function togglePause() {
      isPaused = !isPaused;
      if (isPaused) {
        clearInterval(gameLoop);
        pauseMenu.style.display = 'flex';
      } else {
        pauseMenu.style.display = 'none';
        gameLoop = setInterval(update, 1000 / 60);
      }
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        togglePause();
      }
    });

    document.getElementById('resumeButton').addEventListener('click', togglePause);
    document.getElementById('restartButton').addEventListener('click', () => {
      togglePause();
      startGame();
    });

    document.getElementById('restartGameButton').addEventListener('click', () => {
      gameOverScreen.style.display = 'none';
      startGame();
    });

    backToDeckButton.addEventListener('click', backToLobby);

    function showUpgradeModal(tower) {
      selectedTower = tower;
      upgradeModal.style.display = 'block';
      upgradeOptions.innerHTML = '';

      const upgradeCost = Math.floor(tower.upgradeCost * 0.5);

      const upgradeTypes = [
        { name: 'Alcance', stat: 'range' },
        { name: 'Dano', stat: 'damage' },
        { name: 'Velocidade de Ataque', stat: 'speed' }
      ];

      upgradeTypes.forEach(upgrade => {
        const option = document.createElement('div');
        option.className = `upgrade-option${crystals >= upgradeCost ? '' : ' disabled'}`;
        option.innerHTML = `Melhorar ${upgrade.name} (<span class="resource-icon crystal-icon"></span> ${upgradeCost})`;
        option.onclick = () => {
          if (selectedTower.upgrade(upgrade.stat)) {
            updateResourceInfo();
            showUpgradeModal(selectedTower);
          }
        };
        upgradeOptions.appendChild(option);
      });
    }

    function toggleSpeed() {
      if (gameSpeed === 1) {
        gameSpeed = 2;
        speedToggle.textContent = '2x Velocidade';
        speedToggle.classList.add('active');
      } else {
        gameSpeed = 1;
        speedToggle.textContent = '1x Velocidade';
        speedToggle.classList.remove('active');
      }
    }

    function castBlackHole(x, y) {
      const blackHoleRadius = 80;
      const blackHoleDuration = 180; // 3 seconds
      let remainingDuration = blackHoleDuration;
      const particles = [];

      function updateBlackHole() {
        if (remainingDuration <= 0) return;

        // Draw black hole
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, blackHoleRadius);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
        gradient.addColorStop(0.7, 'rgba(50, 0, 100, 0.5)');
        gradient.addColorStop(1, 'rgba(100, 0, 200, 0.1)');
        
        ctx.beginPath();
        ctx.arc(x, y, blackHoleRadius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Draw event horizon
        ctx.beginPath();
        ctx.arc(x, y, blackHoleRadius * 0.7, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(150, 0, 255, 0.8)';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Create particles being sucked in
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: x + (Math.random() - 0.5) * blackHoleRadius * 2,
            y: y + (Math.random() - 0.5) * blackHoleRadius * 2,
            size: Math.random() * 5 + 2,
            life: 30
          });
        }

        // Update particles
        particles.forEach((p, i) => {
          const dx = x - p.x;
          const dy = y - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < blackHoleRadius) {
            p.x += dx * 0.1;
            p.y += dy * 0.1;
            p.size *= 0.95;
          } else {
            p.x += dx * 0.05;
            p.y += dy * 0.05;
          }

          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(150, 0, 255, ${p.life/30})`;
          ctx.fill();
          p.life--;
          if (p.life <= 0) particles.splice(i, 1);
        });

        // Affect enemies
        enemies.forEach(enemy => {
          const dx = enemy.x - x;
          const dy = enemy.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance <= blackHoleRadius) {
            enemy.x -= dx * 0.1;
            enemy.y -= dy * 0.1;
            
            if (distance < blackHoleRadius * 0.5 && enemy.type !== 'boss') {
              enemy.health = 0;
            }
          }
        });

        remainingDuration--;
        if (remainingDuration > 0) {
          requestAnimationFrame(updateBlackHole);
        }
      }

      updateBlackHole();
    }

    function castSpacetime(x, y) {
      const spacetimeRadius = 400;
      const spacetimeDuration = 180; // 3 seconds
      let remainingDuration = spacetimeDuration;
      const particles = [];
      
      // Save current game state
      const savedState = {
        enemies: [...enemies],
        towers: [...towers],
        projectiles: [...projectiles],
        wave: wave,
        lives: lives,
        gold: gold,
        crystals: crystals
      };

      function updateSpacetime() {
        if (remainingDuration <= 0) {
          // Restore game state
          enemies = savedState.enemies;
          towers = savedState.towers;
          projectiles = savedState.projectiles;
          wave = savedState.wave;
          lives = savedState.lives;
          gold = savedState.gold;
          crystals = savedState.crystals;
          updateResourceInfo();
          updateWaveInfo();
          return;
        }

        // Draw spacetime distortion
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, spacetimeRadius);
        gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
        gradient.addColorStop(1, 'rgba(0, 100, 255, 0.2)');
        
        ctx.beginPath();
        ctx.arc(x, y, spacetimeRadius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Draw swirling time particles
        for (let i = 0; i < 10; i++) {
          const angle = Date.now()/100 + i * Math.PI/5;
          const radius = spacetimeRadius * (remainingDuration/spacetimeDuration);
          const px = x + Math.cos(angle) * radius;
          const py = y + Math.sin(angle) * radius;
          
          ctx.beginPath();
          ctx.arc(px, py, 5, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${remainingDuration/spacetimeDuration})`;
          ctx.fill();
        }

        // Draw clock hands animation
        ctx.save();
        ctx.translate(x, y);
        for (let i = 0; i < 3; i++) {
          const handAngle = Date.now()/100 * (i+1);
          ctx.rotate(handAngle);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(0, -spacetimeRadius * 0.7);
          ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 - i*0.2})`;
          ctx.lineWidth = 3 - i;
          ctx.stroke();
          ctx.rotate(-handAngle);
        }
        ctx.restore();

        remainingDuration--;
        requestAnimationFrame(updateSpacetime);
      }

      updateSpacetime();
    }

    function castVacuum(x, y) {
      const vacuumRadius = 150;
      const vacuumDuration = 60; // 1 second
      let remainingDuration = vacuumDuration;
      const particles = [];
      const shockwaves = [];

      function updateVacuum() {
        if (remainingDuration <= 0) return;

        // Create new particles
        if (remainingDuration % 2 === 0) {
          for (let i = 0; i < 10; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * vacuumRadius;
            particles.push({
              x: x + Math.cos(angle) * radius,
              y: y + Math.sin(angle) * radius,
              size: 2 + Math.random() * 4,
              speed: 0.5 + Math.random(),
              life: 30 + Math.random() * 30,
              color: `hsla(${180 + Math.random() * 40}, 100%, 60%, 0.8)`
            });
          }
        }

        // Draw vortex effect
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, vacuumRadius);
        gradient.addColorStop(0, 'hsla(240, 100%, 50%, 0.9)');
        gradient.addColorStop(0.7, 'hsla(220, 100%, 60%, 0.5)');
        gradient.addColorStop(1, 'hsla(200, 100%, 70%, 0.1)');
        
        ctx.beginPath();
        ctx.arc(x, y, vacuumRadius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Draw spiral pattern
        ctx.save();
        ctx.translate(x, y);
        for (let i = 0; i < 3; i++) {
          const spiralAngle = Date.now()/500 + i * Math.PI*2/3;
          ctx.beginPath();
          for (let r = 0; r < vacuumRadius; r += 5) {
            const angle = spiralAngle + r / 30;
            ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
          }
          ctx.strokeStyle = `hsla(200, 100%, 70%, ${0.5 - i*0.15})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        ctx.restore();

        // Draw particles
        particles.forEach((p, i) => {
          const dx = x - p.x;
          const dy = y - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          // Move particles toward center
          p.x += dx * 0.05 * p.speed;
          p.y += dy * 0.05 * p.speed;
          p.size *= 0.99;
          p.life--;
          
          // Draw particle
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.fill();
          
          if (p.life <= 0 || dist < 5) {
            particles.splice(i, 1);
          }
        });

        // Create shockwave effect on first frame
        if (remainingDuration === vacuumDuration) {
          shockwaves.push({
            radius: 10,
            alpha: 1,
            width: 5
          });
        }

        // Update shockwaves
        shockwaves.forEach((wave, i) => {
          wave.radius += 3;
          wave.alpha -= 0.02;
          wave.width -= 0.1;
          
          ctx.beginPath();
          ctx.arc(x, y, wave.radius, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(0, 200, 255, ${wave.alpha})`;
          ctx.lineWidth = wave.width;
          ctx.stroke();
          
          if (wave.alpha <= 0) {
            shockwaves.splice(i, 1);
          }
        });

        // Affect enemies
        enemies.forEach(enemy => {
          const dx = enemy.x - x;
          const dy = enemy.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance <= vacuumRadius && enemy.type !== 'boss') {
            // Suck enemies toward center
            enemy.x -= dx * 0.03;
            enemy.y -= dy * 0.03;
            
            // Apply damage on first frame
            if (remainingDuration === vacuumDuration) {
              enemy.health *= 0.01; // Remove 99% of health
              
              // Create damage particles
              for (let i = 0; i < 10; i++) {
                particles.push({
                  x: enemy.x,
                  y: enemy.y,
                  size: 3 + Math.random() * 5,
                  speed: 0.2 + Math.random(),
                  life: 20 + Math.random() * 20,
                  color: 'hsla(0, 100%, 70%, 0.8)'
                });
              }
            }
          }
        });

        remainingDuration--;
        if (remainingDuration > 0) {
          requestAnimationFrame(updateVacuum);
        }
      }

      updateVacuum();
    }

    function getTowerCost(towerType) {
      switch (towerType) {
        case 'basic':
          return 50;
        case 'rapid':
          return 170;
        case 'sniper':
          return 250;
        case 'ice':
          return 180;
        case 'laser':
          return 360;
        case 'cannon':
          return 300;
        case 'area':
          return 120;
        case 'chain':
          return 150;
        case 'bomb':
          return 120;
        case 'bazooka':
          return 160;
        case 'threeMages':
          return 150;
        case 'teleport':
          return 250;
        case 'combat':
          return 250;
        case 'mortar':
          return 300;
        case 'tesla':
          return 250;
        case 'superArrows':
          return 170;
        case 'clone':
          return 250;
        case 'goldCollector':
          return 150;
        case 'multiShot':
          return 200;
        case 'seismic':
          return 220;
        case 'repulsao':
          return 280;
        case 'wheeled':
          return 200;
        case 'fragmentation':
          return 250;
        case 'fire':
          return 300;
        case 'poison':
          return 150;
        default:
          return 0;
      }
    }

    function castMeteorShower(x, y) {
      // Get up to 5 random enemies
      const targets = [...enemies].filter(e => e.health > 0).slice(0, 5);
      const meteors = [];
      const particles = [];
      
      // Create meteors
      targets.forEach(target => {
        meteors.push({
          x: x + (Math.random() - 0.5) * 100,
          y: y - 150,
          target: target,
          size: 20 + Math.random() * 10,
          speed: 4 + Math.random() * 3,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.2,
          hit: false,
          particles: []
        });
      });

      function updateMeteors() {
        // Clear finished meteors
        meteors.forEach((meteor, index) => {
          if (meteor.hit && meteor.particles.length === 0) {
            meteors.splice(index, 1);
          }
        });

        if (meteors.length === 0) return;

        // Update meteors
        meteors.forEach(meteor => {
          if (meteor.hit) {
            // Update explosion particles
            meteor.particles.forEach((p, i) => {
              p.x += p.vx;
              p.y += p.vy;
              p.size *= 0.95;
              p.life--;
              if (p.life <= 0) meteor.particles.splice(i, 1);
            });
            return;
          }

          // Move meteor toward target
          const dx = meteor.target.x - meteor.x;
          const dy = meteor.target.y - meteor.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < meteor.speed) {
            // Collision - create explosion
            meteor.hit = true;
            meteor.target.health *= 0.5; // Apply damage on hit
            
            // Create explosion particles
            for (let i = 0; i < 30; i++) {
              const angle = Math.random() * Math.PI * 2;
              const speed = 1 + Math.random() * 3;
              meteor.particles.push({
                x: meteor.x,
                y: meteor.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: 5 + Math.random() * 10,
                life: 30 + Math.random() * 30,
                color: `hsl(${20 + Math.random() * 20}, 100%, 50%)`
              });
            }
          } else {
            meteor.x += dx / dist * meteor.speed;
            meteor.y += dy / dist * meteor.speed;
            meteor.rotation += meteor.rotationSpeed;
            
            // Create trail particles
            if (Math.random() < 0.3) {
              meteor.particles.push({
                x: meteor.x - dx/dist * meteor.size/2,
                y: meteor.y - dy/dist * meteor.size/2,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                size: meteor.size * 0.5,
                life: 20,
                color: `hsl(${30 + Math.random() * 10}, 100%, 50%)`
              });
            }
          }
        });

        // Draw all meteors and particles
        ctx.save();
        meteors.forEach(meteor => {
          if (!meteor.hit) {
            // Draw meteor
            ctx.save();
            ctx.translate(meteor.x, meteor.y);
            ctx.rotate(meteor.rotation);
            
            // Meteor body
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, meteor.size);
            gradient.addColorStop(0, '#FF4500');
            gradient.addColorStop(0.7, '#B22222');
            gradient.addColorStop(1, '#8B0000');
            
            ctx.beginPath();
            ctx.arc(0, 0, meteor.size, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Meteor details
            ctx.beginPath();
            ctx.moveTo(0, 0);
            for (let i = 0; i < 5; i++) {
              const angle = i * Math.PI * 0.4;
              const spikeLength = meteor.size * 1.5;
              ctx.lineTo(
                Math.cos(angle) * spikeLength,
                Math.sin(angle) * spikeLength
              );
              ctx.lineTo(
                Math.cos(angle + 0.2) * meteor.size * 0.8,
                Math.sin(angle + 0.2) * meteor.size * 0.8
              );
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 165, 0, 0.7)';
            ctx.fill();
            
            ctx.restore();
          }
          
          // Draw particles
          meteor.particles.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
          });
        });
        ctx.restore();

        requestAnimationFrame(updateMeteors);
      }

      updateMeteors();
    }

    function castTerraQueimada(x, y) {
      const radius = 120;
      const duration = 600; // 10 seconds at 60fps
      const damagePerSecond = 15;
      let remainingDuration = duration;
      const fireParticles = [];
      
      function updateTerraQueimada() {
        if (remainingDuration <= 0) return;
        
        // Draw burning ground
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
        gradient.addColorStop(0.7, 'rgba(200, 50, 0, 0.5)');
        gradient.addColorStop(1, 'rgba(100, 20, 0, 0.2)');
        
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Draw flames at the edge
        for (let i = 0; i < 12; i++) {
          const angle = Date.now()/500 + i * Math.PI/6;
          const flameX = x + Math.cos(angle) * radius * 0.8;
          const flameY = y + Math.sin(angle) * radius * 0.8;
          const flameHeight = 30 + Math.sin(Date.now()/200 + i) * 15;
          
          ctx.beginPath();
          ctx.moveTo(flameX - 10, flameY);
          ctx.quadraticCurveTo(flameX, flameY - flameHeight, flameX + 10, flameY);
          ctx.fillStyle = `rgba(255, ${150 + Math.random() * 100}, 0, 0.7)`;
          ctx.fill();
        }
        
        // Create fire particles
        if (remainingDuration % 3 === 0) {
          for (let i = 0; i < 5; i++) {
            fireParticles.push({
              x: x + (Math.random() - 0.5) * radius * 0.8,
              y: y + (Math.random() - 0.5) * radius * 0.8,
              vx: (Math.random() - 0.5) * 1,
              vy: -Math.random() * 3,
              size: 5 + Math.random() * 10,
              life: 30 + Math.random() * 30
            });
          }
        }
        
        // Update and draw particles
        fireParticles.forEach((p, i) => {
          p.x += p.vx;
          p.y += p.vy;
          p.size *= 0.98;
          p.life--;
          
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${p.life/60})`;
          ctx.fill();
          
          if (p.life <= 0) {
            fireParticles.splice(i, 1);
          }
        });
        
        // Damage enemies in area
        enemies.forEach(enemy => {
          const dx = enemy.x - x;
          const dy = enemy.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= radius) {
            enemy.health -= damagePerSecond / 60; // Damage per frame
          }
        });
        
        remainingDuration--;
        if (remainingDuration > 0) {
          requestAnimationFrame(updateTerraQueimada);
        }
      }
      
      updateTerraQueimada();
    }

    function castTempestadeEletrica(x, y) {
      const maxTargets = 5;
      const damage = 50;
      const targets = [...enemies].filter(e => e.health > 0).slice(0, maxTargets);
      
      if (targets.length === 0) return;

      const particles = [];
      const lightningPaths = [];
      
      // Create lightning paths to each target
      targets.forEach(target => {
        lightningPaths.push({
          x1: x,
          y1: y,
          x2: target.x,
          y2: target.y,
          segments: [],
          life: 30
        });
        
        // Apply damage
        target.health -= damage;
        
        // Create impact particles
        for (let i = 0; i < 10; i++) {
          particles.push({
            x: target.x + (Math.random() - 0.5) * 20,
            y: target.y + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            size: 2 + Math.random() * 4,
            life: 20 + Math.random() * 20,
            color: `hsl(${200 + Math.random() * 40}, 100%, 70%)`
          });
        }
      });

      // Generate jagged segments for lightning paths
      lightningPaths.forEach(path => {
        const segments = 8;
        for (let i = 1; i <= segments; i++) {
          const t = i / segments;
          const offset = (i % 2 === 0 ? 1 : -1) * 15 * (1 - t);
          path.segments.push({
            x: path.x1 + (path.x2 - path.x1) * t + (Math.random() - 0.5) * offset,
            y: path.y1 + (path.y2 - path.y1) * t + (Math.random() - 0.5) * offset
          });
        }
      });

      function updateTempestade() {
        // Draw lightning paths
        lightningPaths.forEach(path => {
          ctx.beginPath();
          ctx.moveTo(path.x1, path.y1);
          
          path.segments.forEach(segment => {
            ctx.lineTo(segment.x, segment.y);
          });
          
          ctx.lineTo(path.x2, path.y2);
          ctx.strokeStyle = `rgba(100, 200, 255, ${path.life/30})`;
          ctx.lineWidth = 3;
          ctx.stroke();
          
          // Draw impact glow
          ctx.beginPath();
          ctx.arc(path.x2, path.y2, 15, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(100, 200, 255, ${path.life/60})`;
          ctx.fill();
          
          path.life--;
        });

        // Update and draw particles
        particles.forEach((p, i) => {
          p.x += p.vx;
          p.y += p.vy;
          p.size *= 0.95;
          p.life--;
          
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.fill();
          
          if (p.life <= 0) {
            particles.splice(i, 1);
          }
        });

        // Remove completed lightning paths
        for (let i = lightningPaths.length - 1; i >= 0; i--) {
          if (lightningPaths[i].life <= 0) {
            lightningPaths.splice(i, 1);
          }
        }

        if (lightningPaths.length > 0 || particles.length > 0) {
          requestAnimationFrame(updateTempestade);
        }
      }

      updateTempestade();
    }

    function castClone(tower) {
      // Create a temporary clone of the tower with 25% less damage
      const clone = new Tower(tower.x + 30, tower.y + 30, tower.type);
      clone.damage = tower.damage * 0.75; // 25% less damage
      clone.isCloned = true;
      clone.pulsePhase = 0;
      
      // Add the clone to towers array
      towers.push(clone);
      
      // Set timeout to remove the clone after 9 seconds
      setTimeout(() => {
        const index = towers.indexOf(clone);
        if (index !== -1) {
          towers.splice(index, 1);
        }
      }, 9000);
    }

    function castFuria(tower) {
      const originalCooldown = tower.cooldown;
      const originalSpeed = tower.moveSpeed;
      
      // Triple attack speed
      tower.cooldown = Math.max(1, Math.floor(tower.cooldown / 3));
      
      // If it's a wheeled tower, also increase movement speed
      if (tower.type === 'wheeled') {
        tower.moveSpeed *= 3;
      }
      
      // Visual effect
      const startTime = Date.now();
      const duration = 5000; // 5 seconds
      
      function updateFuriaEffect() {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress >= 1) {
          // Restore original values
          tower.cooldown = originalCooldown;
          if (tower.type === 'wheeled') {
            tower.moveSpeed = originalSpeed;
          }
          return;
        }
        
        // Pulsing red effect
        const pulseValue = Math.sin(progress * Math.PI * 10) * 0.5 + 0.5;
        ctx.save();
        ctx.translate(tower.x, tower.y);
        ctx.beginPath();
        ctx.arc(0, 0, 25, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 0, 0, ${0.3 * pulseValue})`;
        ctx.fill();
        ctx.restore();
        
        requestAnimationFrame(updateFuriaEffect);
      }
      
      updateFuriaEffect();
    }

    generateWave();

    gameLoop = setInterval(update, 1000 / 60);
  </script>
</body>
</html>